package strconv

import "math"
import "strings"
import "strconv"
import "errors"

// These are the different modes for Prefix string conversion.
const (
	// SI uses a scaling of 1000x, and uses the single letter symbol to denote
	// the scaling. The prefixes ranges from Yocto (1E-24) to Yotta (1E+24).
	//
	// The output uses SI prefixes, and uses 'k' for Kilo and 'μ' for Micro.
	// The iput accepts SI prefixes along with 'k' and 'K' for Kilo and
	// 'μ' and 'u' for Micro.
	// It does not support the Deca, Hecto, Deci, or Centi prefixes.
	SI = iota

	// Base1024 uses a scaling of 1024x, but uses the same prefixes as SI. This
	// is a non-standard prefix notation and exists because many legacy systems
	// unfortunately operate in this way.
	//
	// The output uses SI prefixes, but uses 'K' for Kilo and 'u' for Micro.
	// The Input accepts SI prefixes along with 'k' and 'K' for Kilo and
	// 'μ' and 'u' for Micro. It also accepts IEC notation.
	Base1024

	// IEC uses a scaling of 1024x, and uses a two-letter symbol to denote the
	// scaling in a system similar to SI. Instead of Kilo denoted as 'k', it
	// uses Kibi denoted as 'Ki'. The prefixes ranges from Unit (1) to Yobi
	// (1<<80). Representing values less than 1 will not use any of the divisor
	// prefixes. IEC notation is easy to identify since the prefix symbols
	// always end with the letter 'i'.
	//
	// The output uses IEC prefixes that are Unit and greater.
	// The input accepts IEC prefixes only.
	IEC
)

// Prefix factors according to IEC standards.
const (
	// These are not standard IEC prefixes, but used internally.
	yocbi = 1.0 / (1 << 80)
	zepbi = 1.0 / (1 << 70)
	attbi = 1.0 / (1 << 60)
	fembi = 1.0 / (1 << 50)
	picbi = 1.0 / (1 << 40)
	nanbi = 1.0 / (1 << 30)
	micbi = 1.0 / (1 << 20)
	milbi = 1.0 / (1 << 10)

	_ = 1 << 0

	Kibi = 1 << 10
	Mebi = 1 << 20
	Gibi = 1 << 30
	Tebi = 1 << 40
	Pebi = 1 << 50
	Exbi = 1 << 60
	Zebi = 1 << 70
	Yobi = 1 << 80
)

// Prefix factors according to SI standards.
const (
	Yocto = 1E-24
	Zepto = 1E-21
	Atto  = 1E-18
	Femto = 1E-15
	Pico  = 1E-12
	Nano  = 1E-9
	Micro = 1E-6
	Milli = 1E-3

	Unit = 1E0 // Not a standard SI prefix.

	Kilo  = 1E+3
	Mega  = 1E+6
	Giga  = 1E+9
	Tera  = 1E+12
	Peta  = 1E+15
	Exa   = 1E+18
	Zetta = 1E+21
	Yotta = 1E+24
)

const (
	prefixes = divPrefixes + string(unitPrefix) + mulPrefixes

	divPrefixes = "yzafpnum"
	unitPrefix  = '.'
	mulPrefixes = "KMGTPEZY"

	parsePrefixes = divPrefixes + mulPrefixes + string(kiloAlt) + string(microAlt)

	maxExp = +len(mulPrefixes)
	minExp = -len(divPrefixes)

	kilo, kiloAlt   = 'K', 'k'
	micro, microAlt = 'u', 'μ'
)

var scaleSI = []float64{
	Yocto, Zepto, Atto, Femto, Pico, Nano, Micro, Milli,
	Unit,
	Kilo, Mega, Giga, Tera, Peta, Exa, Zetta, Yotta,
}

var scaleIEC = []float64{
	yocbi, zepbi, attbi, fembi, picbi, nanbi, micbi, milbi,
	Unit,
	Kibi, Mebi, Gibi, Tebi, Pebi, Exbi, Zebi, Yobi,
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// Using a combination of the math.LogX and math.Pow functions can be lossy.
// This leads to slightly wrong values around the prefix boundaries. Thus, we
// look up the computed exponent in an authoritative list of scalings and
// adjust accordingly.
func adjustLog(val float64, scales []float64, minExp, exp, maxExp int) int {
	lo, hi := max(exp-1, minExp), min(exp+1, maxExp)
	for exp = hi; exp >= lo; exp-- {
		if scales[exp+len(scales)/2] <= math.Abs(val) {
			break
		}
	}
	return max(min(exp, maxExp), minExp)
}

// AppendPrefix appends the string form of the floating-point number val, as
// generated by FormatPrefix, to dst and returns the extended buffer.
func AppendPrefix(dst []byte, val float64, mode int, prec int) (out []byte) {
	if math.IsNaN(val) || math.IsInf(val, 0) {
		return strconv.AppendFloat(dst, val, 'f', -1, 64)
	}

	// Compute the prefix exponent.
	var exp int
	if val != 0 {
		switch mode {
		case SI:
			exp = int(math.Floor(math.Log10(math.Abs(val)) / 3))
			exp = adjustLog(val, scaleSI, minExp, exp, maxExp)
			val /= scaleSI[exp+len(scaleSI)/2] // Same as: Pow(1000, exp)
		case Base1024:
			exp = int(math.Floor(math.Log2(math.Abs(val)) / 10))
			exp = adjustLog(val, scaleIEC, minExp, exp, maxExp)
			val /= scaleIEC[exp+len(scaleSI)/2] // Same as: Pow(1024, exp)
		case IEC:
			exp = int(math.Floor(math.Log2(math.Abs(val)) / 10))
			exp = adjustLog(val, scaleIEC, 0, exp, maxExp)
			val /= scaleIEC[exp+len(scaleSI)/2] // Same as: Pow(1024, exp)
		default:
			return strconv.AppendInt(append(dst, '%'), int64(mode), 10)
		}
	} else {
		exp = 0
	}

	// Print the actual number.
	dst = strconv.AppendFloat(dst, val, 'f', prec, 64)

	// Print the prefix symbol.
	if exp != 0 {
		var sym byte
		sym = prefixes[exp+len(prefixes)/2]
		switch {
		case mode == SI && sym == kilo:
			dst = append(dst, kiloAlt)
		case mode == SI && sym == micro:
			dst = append(dst, string(microAlt)...) // Uses UTF-8.
		default:
			dst = append(dst, sym)
		}
		if mode == IEC {
			dst = append(dst, 'i')
		}
	}
	return dst
}

// FormatPrefix converts the floating-point number val to a string, according
// to the prefix notation specified by mode. The prec specifies the precision
// used by the numeric portion.
//
// Even if prec is -1, formatting a value and parsing it does not guarantee that
// the exact value will be returned. It will however be extremely accurate.
//
// It is valid to format +Inf, -Inf, and NaN.
func FormatPrefix(val float64, mode int, prec int) (str string) {
	return string(AppendPrefix(nil, val, mode, prec))
}

// ParsePrefix converts the string str to a floating-point number, according to
// the prefix notation specified by mode.
//
// It is valid to parse +Inf, -Inf, and NaN.
func ParsePrefix(str string, mode int) (val float64, err error) {
	val, err = strconv.ParseFloat(str, 64)
	if err == nil && math.IsNaN(val) || math.IsInf(val, 0) {
		return val, nil
	}
	err = nil // Reset the error

	// Parse the prefix symbol.
	var exp int
	var saveStr = str
	i := strings.IndexAny(str, parsePrefixes)
	if i >= 0 {
		strPre := str[i:]
		str = str[:i]

		if mode == IEC && len(strPre) != 2 {
			goto fail // Syntax error
		}
		for si, ch := range strPre {
			switch si {
			case 0:
				if mode == IEC && (ch == kiloAlt || ch == microAlt) {
					goto fail // Syntax error
				}
				switch ch {
				case kiloAlt:
					ch = kilo
				case microAlt:
					ch = micro
				}
				exp = strings.IndexByte(prefixes, byte(ch)) - len(prefixes)/2
				if mode == IEC && exp < 0 {
					goto fail // Syntax error
				}
			case 1:
				if mode == SI || ch != 'i' {
					goto fail // Syntax error
				}
			default:
				goto fail // Syntax error
			}
		}
	}

	// Parse the number part.
	for _, ch := range str {
		switch ch {
		case '-', '+', '.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
		default:
			goto fail // Syntax error
		}
	}
	if val, err = strconv.ParseFloat(str, 64); err != nil {
		goto fail
	}

	// Compute the actual value.
	switch mode {
	case SI:
		return val * scaleSI[exp+len(scaleSI)/2], nil
	case Base1024, IEC:
		return val * scaleIEC[exp+len(scaleSI)/2], nil
	default:
		return 0, errors.New("strconv: invalid mode")
	}

fail:
	if err == nil {
		err = strconv.ErrSyntax
	}
	if nerr, ok := err.(*strconv.NumError); ok {
		err = nerr.Err
	}
	err = &strconv.NumError{Func: "ParsePrefix", Num: saveStr, Err: err}
	return val, err
}
